"use strict";

(function (window) {
  function getSkewOffset(skewDeg, widthHalf) {
    const skewRad = Math.tan(0.017453 * Math.abs(skewDeg));
    return Math.ceil(widthHalf * skewRad);
  }

  function hexToRgb(hex) {
    if (!/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) return { r: 0, g: 0, b: 0 };

    let c = hex.substring(1).split("");
    if (c.length === 3) {
      c = [c[0], c[0], c[1], c[1], c[2], c[2]];   // shapes array
    }
    c = "0x" + c.join("");
    return {
      r: (c >> 16) & 255,
      g: (c >> 8) & 255,
      b: c & 255,
    };
  }

  class Particle {
    constructor(color, quadrant, options) { // function for particle class
      this.options = options;
      this.rgb = hexToRgb(color);
      this.direction = this.randomDirection();
      this.shape = this.randomShape();
      this.size = Math.abs(this.getRandom(options.size));
      this.setRandomPosition(quadrant);
      this.vx = this.getRandom(options.speed.x) * this.randomDirection();
      this.vy = this.getRandom(options.speed.y) * this.randomDirection();
    }

    setRandomPosition(quadrant) {
      const pos = this.getRandomQuadrantPosition();
      switch (quadrant) {
        case 3:
          this.x = pos.x + pos.halfWidth;
          this.y = pos.y;
          break;
        case 2:
          this.x = pos.x;
          this.y = pos.y + pos.halfHeight;
          break;
        case 1:
          this.x = pos.x + pos.halfWidth;
          this.y = pos.y + pos.halfHeight;
          break;
        default:
          this.x = pos.x;
          this.y = pos.y;
      }
    }

    getRandomQuadrantPosition() {
      const w = this.options.c.w / 2;
      const h = this.options.c.h / 2;
      return {
        x: Math.random() * w,
        y: Math.random() * h,
        halfWidth: w,
        halfHeight: h,
      };
    }

    getRandom(setting) {
      if (setting.min === setting.max) return setting.min;
      const range = setting.max - setting.min;
      return Math.random() * range + setting.min;
    }

    randomDirection() {  // randomly determines either a positive or negative direction
      return Math.random() > 0.5 ? 1 : -1; 
    }

    randomShape() {
      return this.options.shapes[Math.floor(Math.random() * this.options.shapes.length)];
    }   // randomly generates an int index that can be used to access an element in the shapes array

    getColor(rgba, opacity) {
      return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${opacity})`;
    }

    animate(ctx, width, height) {
      const { size, opacity, blending, size: { pulse } } = this.options;

      if (pulse) {
        this.size += pulse * this.direction;
        if (this.size > size.max || this.size < size.min) this.direction *= -1;
        this.size = Math.abs(this.size);
      }

      this.x += this.vx;
      this.y += this.vy;

      if (this.x < 0 || this.x > width) this.vx *= -1;
      if (this.y < 0 || this.y > height) this.vy *= -1;

      ctx.beginPath();
      if (blending && blending !== "none") ctx.globalCompositeOperation = blending;

      const colorCenter = this.getColor(this.rgb, opacity.center);
      const colorEdge = this.getColor(this.rgb, opacity.edge);
      let radius;
      switch (this.shape) {
        case "c":
          radius = this.size / 2;
          break;
        case "t":
          radius = 0.577 * this.size;
          break;
        case "s":
          radius = 0.707 * this.size;
          break;
        default:
          radius = this.size;
      }

      const gradient = ctx.createRadialGradient(this.x, this.y, 0.01, this.x, this.y, radius);
      gradient.addColorStop(0, colorCenter);
      gradient.addColorStop(1, colorEdge);
      ctx.fillStyle = gradient;

      const r = Math.abs(this.size / 2);
      if (this.shape === "c") {
        ctx.arc(this.x, this.y, r, 0, 2 * Math.PI);
      } else if (this.shape === "s") {
        ctx.rect(this.x - r, this.y - r, r * 2, r * 2);
      } else if (this.shape === "t") {
        const height = getSkewOffset(30, r);
        ctx.moveTo(this.x - r, this.y + height);
        ctx.lineTo(this.x + r, this.y + height);
        ctx.lineTo(this.x, this.y - 2 * height);
        ctx.closePath();
      }

      ctx.fill();
    }
  }

  class FinisherHeader {
    constructor(options) {
      this.canvas = document.createElement("canvas");
      this.ctx = this.canvas.getContext("2d");
      this.canvas.setAttribute("id", "finisher-canvas");

      this.container = this.getContainer(options.className);
      this.container.appendChild(this.canvas);

      window.addEventListener("resize", () => this.resize(), false);

      this.init(options);
      window.requestAnimationFrame(() => this.animate());
    }

    getContainer(className) {
      const elements = document.getElementsByClassName(className || "finisher-header");
      if (!elements.length) throw new Error("No .finisher-header element found");
      return elements[0];
    }

    resize() {
      const container = this.getContainer(this.options.className);
      this.options.c = {
        w: container.clientWidth,
        h: container.clientHeight,
      };
      this.canvas.width = this.options.c.w;
      this.canvas.height = this.options.c.h;

      const offset = getSkewOffset(this.options.skew, this.options.c.w / 2);
      const transform = `skewY(${this.options.skew}deg) translateY(-${offset}px)`;
      this.canvas.setAttribute("style", `position:absolute;z-index:-1;top:0;left:0;right:0;bottom:0;-webkit-transform:${transform};transform:${transform};outline: 1px solid transparent;background-color:rgba(${this.bgColor.r},${this.bgColor.g},${this.bgColor.b},1);`);
    }

    init(options) {
      this.options = options;
      this.bgColor = hexToRgb(this.options.colors.background);
      this.particles = [];
      this.resize();
      this.createParticles();
    }

    createParticles() {
      let colorIndex = 0;
      const count = window.innerWidth < 600 && this.options.count > 5 ? Math.round(this.options.count / 2) : this.options.count;
      for (let i = 0; i < count; i++) {
        const quadrant = i % 4;
        const color = this.options.colors.particles[colorIndex];
        this.particles[i] = new Particle(color, quadrant, this.options);
        if (++colorIndex >= this.options.colors.particles.length) colorIndex = 0;
      }
    }

    animate() {
      window.requestAnimationFrame(() => this.animate());
      this.ctx.clearRect(0, 0, this.options.c.w, this.options.c.h);
      for (let p of this.particles) {
        p.animate(this.ctx, this.options.c.w, this.options.c.h);
      }
    }
  }

  window.FinisherHeader = FinisherHeader;
})(window);
